import * as React from "react";
import * as THREE from "three";
import create from "zustand";
import { useThree } from "@react-three/fiber";
import { XRController } from "./XRController.mjs";
import { InteractionManager } from "./Interactions.mjs";
import { useCallbackRef, useIsomorphicLayoutEffect, uniq } from "./utils.mjs";
const XRContext = React.createContext(null);
const globalSessionStore = create((set, get) => ({ set, get, session: null, referenceSpaceType: null }));
function XRManager({
  foveation = 0,
  referenceSpace = "local-floor",
  onSessionStart,
  onSessionEnd,
  onVisibilityChange,
  onInputSourcesChange,
  children
}) {
  const gl = useThree((state) => state.gl);
  const camera = useThree((state) => state.camera);
  const player = useXR((state) => state.player);
  const get = useXR((state) => state.get);
  const set = useXR((state) => state.set);
  const session = useXR((state) => state.session);
  const controllers = useXR((state) => state.controllers);
  const onSessionStartRef = useCallbackRef(onSessionStart);
  const onSessionEndRef = useCallbackRef(onSessionEnd);
  const onVisibilityChangeRef = useCallbackRef(onVisibilityChange);
  const onInputSourcesChangeRef = useCallbackRef(onInputSourcesChange);
  useIsomorphicLayoutEffect(() => {
    const handlers = [0, 1].map((id) => {
      const target = new XRController(id, gl);
      const onConnected = () => set((state) => ({ controllers: [...state.controllers, target] }));
      const onDisconnected = () => set((state) => ({ controllers: state.controllers.filter((it) => it !== target) }));
      target.addEventListener("connected", onConnected);
      target.addEventListener("disconnected", onDisconnected);
      return () => {
        target.removeEventListener("connected", onConnected);
        target.removeEventListener("disconnected", onDisconnected);
      };
    });
    return () => handlers.forEach((cleanup) => cleanup());
  }, [gl, set]);
  useIsomorphicLayoutEffect(() => globalSessionStore.subscribe(({ session: session2 }) => set(() => ({ session: session2 }))), [gl.xr, set]);
  useIsomorphicLayoutEffect(() => {
    gl.xr.setFoveation(foveation);
    set(() => ({ foveation }));
  }, [gl.xr, foveation, set]);
  useIsomorphicLayoutEffect(() => {
    const globalSessionState = globalSessionStore.getState();
    gl.xr.setReferenceSpaceType(referenceSpace);
    set(() => ({ referenceSpace }));
    globalSessionState.set({ referenceSpaceType: referenceSpace });
  }, [gl.xr, referenceSpace, set]);
  useIsomorphicLayoutEffect(() => {
    if (!session)
      return void gl.xr.setSession(null);
    const handleSessionStart = (nativeEvent) => {
      var _a;
      set(() => ({ isPresenting: true }));
      (_a = onSessionStartRef.current) == null ? void 0 : _a.call(onSessionStartRef, { nativeEvent: { ...nativeEvent, target: session }, target: session });
    };
    const handleSessionEnd = (nativeEvent) => {
      var _a;
      set(() => ({ isPresenting: false, session: null }));
      globalSessionStore.setState(() => ({ session: null }));
      (_a = onSessionEndRef.current) == null ? void 0 : _a.call(onSessionEndRef, { nativeEvent: { ...nativeEvent, target: session }, target: session });
    };
    const handleVisibilityChange = (nativeEvent) => {
      var _a;
      (_a = onVisibilityChangeRef.current) == null ? void 0 : _a.call(onVisibilityChangeRef, { nativeEvent, target: session });
    };
    const handleInputSourcesChange = (nativeEvent) => {
      var _a;
      const isHandTracking = Object.values(session.inputSources).some((source) => source.hand);
      set(() => ({ isHandTracking }));
      (_a = onInputSourcesChangeRef.current) == null ? void 0 : _a.call(onInputSourcesChangeRef, { nativeEvent, target: session });
    };
    gl.xr.addEventListener("sessionstart", handleSessionStart);
    gl.xr.addEventListener("sessionend", handleSessionEnd);
    session.addEventListener("visibilitychange", handleVisibilityChange);
    session.addEventListener("inputsourceschange", handleInputSourcesChange);
    gl.xr.setSession(session).then(() => {
      gl.xr.setFoveation(get().foveation);
    });
    return () => {
      gl.xr.removeEventListener("sessionstart", handleSessionStart);
      gl.xr.removeEventListener("sessionend", handleSessionEnd);
      session.removeEventListener("visibilitychange", handleVisibilityChange);
      session.removeEventListener("inputsourceschange", handleInputSourcesChange);
    };
  }, [session, gl.xr, set, get]);
  return /* @__PURE__ */ React.createElement(InteractionManager, null, /* @__PURE__ */ React.createElement("primitive", {
    object: player
  }, /* @__PURE__ */ React.createElement("primitive", {
    object: camera
  }), controllers.map((controller) => /* @__PURE__ */ React.createElement("primitive", {
    key: controller.index,
    object: controller
  }))), children);
}
function XR(props) {
  const store = React.useMemo(
    () => create((set, get) => ({
      set,
      get,
      controllers: [],
      isPresenting: false,
      isHandTracking: false,
      player: new THREE.Group(),
      session: null,
      foveation: 0,
      referenceSpace: "local-floor",
      hoverState: {
        left: /* @__PURE__ */ new Map(),
        right: /* @__PURE__ */ new Map(),
        none: /* @__PURE__ */ new Map()
      },
      interactions: /* @__PURE__ */ new Map(),
      hasInteraction(object, eventType) {
        var _a;
        return !!((_a = get().interactions.get(object)) == null ? void 0 : _a[eventType].some((handlerRef) => handlerRef.current));
      },
      getInteraction(object, eventType) {
        var _a;
        return (_a = get().interactions.get(object)) == null ? void 0 : _a[eventType].reduce((result, handlerRef) => {
          if (handlerRef.current) {
            result.push(handlerRef.current);
          }
          return result;
        }, []);
      },
      addInteraction(object, eventType, handlerRef) {
        const interactions = get().interactions;
        if (!interactions.has(object)) {
          interactions.set(object, {
            onHover: [],
            onBlur: [],
            onSelect: [],
            onSelectEnd: [],
            onSelectStart: [],
            onSelectMissed: [],
            onSqueeze: [],
            onSqueezeEnd: [],
            onSqueezeStart: [],
            onSqueezeMissed: [],
            onMove: []
          });
        }
        const target = interactions.get(object);
        target[eventType].push(handlerRef);
      },
      removeInteraction(object, eventType, handlerRef) {
        const target = get().interactions.get(object);
        if (target) {
          const interactionIndex = target[eventType].indexOf(handlerRef);
          if (interactionIndex !== -1)
            target[eventType].splice(interactionIndex, 1);
        }
      }
    })),
    []
  );
  return /* @__PURE__ */ React.createElement(XRContext.Provider, {
    value: store
  }, /* @__PURE__ */ React.createElement(XRManager, {
    ...props
  }));
}
const getSessionOptions = (globalStateReferenceSpaceType, sessionInit) => {
  var _a;
  if (!globalStateReferenceSpaceType && !sessionInit) {
    return void 0;
  }
  if (globalStateReferenceSpaceType && !sessionInit) {
    return { optionalFeatures: [globalStateReferenceSpaceType] };
  }
  if (globalStateReferenceSpaceType && sessionInit) {
    return { ...sessionInit, optionalFeatures: uniq([...(_a = sessionInit.optionalFeatures) != null ? _a : [], globalStateReferenceSpaceType]) };
  }
  return sessionInit;
};
const XRButton = React.forwardRef(function XRButton2({ mode, sessionInit, enterOnly = false, exitOnly = false, onClick, onError, children, ...props }, ref) {
  const [status, setStatus] = React.useState("exited");
  const label = status === "unsupported" ? `${mode} unsupported` : `${status === "entered" ? "Exit" : "Enter"} ${mode}`;
  const sessionMode = mode === "inline" ? mode : `immersive-${mode.toLowerCase()}`;
  const onErrorRef = useCallbackRef(onError);
  useIsomorphicLayoutEffect(() => {
    if (!(navigator == null ? void 0 : navigator.xr))
      return void setStatus("unsupported");
    navigator.xr.isSessionSupported(sessionMode).then((supported) => setStatus(supported ? "exited" : "unsupported"));
  }, [sessionMode]);
  useIsomorphicLayoutEffect(
    () => globalSessionStore.subscribe((state) => {
      if (state.session) {
        setStatus("entered");
      } else if (status !== "unsupported") {
        setStatus("exited");
      }
    }),
    [status]
  );
  const toggleSession = React.useCallback(
    async (event) => {
      onClick == null ? void 0 : onClick(event);
      const xrState = globalSessionStore.getState();
      if (xrState.session && enterOnly)
        return;
      if (!xrState.session && exitOnly)
        return;
      let session = null;
      try {
        if (xrState.session) {
          await xrState.session.end();
        } else {
          const options = getSessionOptions(xrState.referenceSpaceType, sessionInit);
          session = await navigator.xr.requestSession(sessionMode, options);
        }
        xrState.set(() => ({ session }));
      } catch (e) {
        const onError2 = onErrorRef.current;
        if (onError2 && e instanceof Error)
          onError2(e);
        else
          throw e;
      }
    },
    [onClick, enterOnly, exitOnly, sessionMode, sessionInit, onErrorRef]
  );
  return /* @__PURE__ */ React.createElement("button", {
    ...props,
    ref,
    onClick: status === "unsupported" ? onClick : toggleSession
  }, typeof children === "function" ? children(status) : children != null ? children : label);
});
const buttonStyles = {
  position: "absolute",
  bottom: "24px",
  left: "50%",
  transform: "translateX(-50%)",
  padding: "12px 24px",
  border: "1px solid white",
  borderRadius: "4px",
  background: "rgba(0, 0, 0, 0.1)",
  color: "white",
  font: "normal 0.8125rem sans-serif",
  outline: "none",
  zIndex: 99999,
  cursor: "pointer"
};
const ARButton = React.forwardRef(
  ({
    style = buttonStyles,
    sessionInit = {
      domOverlay: typeof document !== "undefined" ? { root: document.body } : void 0,
      optionalFeatures: ["hit-test", "dom-overlay", "dom-overlay-for-handheld-ar"]
    },
    children,
    ...rest
  }, ref) => /* @__PURE__ */ React.createElement(XRButton, {
    ...rest,
    ref,
    mode: "AR",
    style,
    sessionInit
  }, children)
);
const VRButton = React.forwardRef(
  ({
    style = buttonStyles,
    sessionInit = { optionalFeatures: ["local-floor", "bounded-floor", "hand-tracking", "layers"] },
    children,
    ...rest
  }, ref) => /* @__PURE__ */ React.createElement(XRButton, {
    ...rest,
    ref,
    mode: "VR",
    style,
    sessionInit
  }, children)
);
function useXR(selector = (state) => state, equalityFn) {
  const store = React.useContext(XRContext);
  if (!store)
    throw new Error("useXR must be used within an <XR /> component!");
  return store(selector, equalityFn);
}
function useController(handedness) {
  const controllers = useXR((state) => state.controllers);
  const controller = React.useMemo(
    () => controllers.find(({ inputSource }) => inputSource.handedness === handedness),
    [handedness, controllers]
  );
  return controller;
}
export {
  ARButton,
  VRButton,
  XR,
  XRButton,
  useController,
  useXR
};
//# sourceMappingURL=XR.mjs.map
