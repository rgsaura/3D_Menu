import {
  OculusHandModel,
  XRControllerModelFactory
} from "./chunk-FWRNTQPL.js";
import {
  create,
  createPortal,
  extend,
  useFrame,
  useThree
} from "./chunk-2CPXGY2R.js";
import {
  require_react
} from "./chunk-OXAWTBIM.js";
import {
  BufferGeometry,
  Group,
  Matrix4,
  Vector3
} from "./chunk-YJHWMUDS.js";
import {
  __toESM
} from "./chunk-Y4AOG3KG.js";

// node_modules/@react-three/xr/dist/Controllers.mjs
var React4 = __toESM(require_react(), 1);

// node_modules/@react-three/xr/dist/XR.mjs
var React3 = __toESM(require_react(), 1);

// node_modules/@react-three/xr/dist/XRController.mjs
var XRController = class extends Group {
  constructor(index, gl) {
    super();
    this.index = index;
    this.controller = gl.xr.getController(index);
    this.grip = gl.xr.getControllerGrip(index);
    this.hand = gl.xr.getHand(index);
    this.grip.userData.name = "grip";
    this.controller.userData.name = "controller";
    this.hand.userData.name = "hand";
    this.visible = false;
    this.add(this.controller, this.grip, this.hand);
    this._onConnected = this._onConnected.bind(this);
    this._onDisconnected = this._onDisconnected.bind(this);
    this.controller.addEventListener("connected", this._onConnected);
    this.controller.addEventListener("disconnected", this._onDisconnected);
  }
  _onConnected(event) {
    if (event.fake)
      return;
    this.visible = true;
    this.inputSource = event.data;
    this.dispatchEvent(event);
  }
  _onDisconnected(event) {
    if (event.fake)
      return;
    this.visible = false;
    this.dispatchEvent(event);
  }
  dispose() {
    this.controller.removeEventListener("connected", this._onConnected);
    this.controller.removeEventListener("disconnected", this._onDisconnected);
  }
};

// node_modules/@react-three/xr/dist/Interactions.mjs
var React2 = __toESM(require_react(), 1);

// node_modules/@react-three/xr/dist/utils.mjs
var React = __toESM(require_react(), 1);
var _a;
var _b;
var uniq = (arr) => Array.from(new Set(arr));
var useIsomorphicLayoutEffect = typeof window !== "undefined" && (((_a = window.document) == null ? void 0 : _a.createElement) || ((_b = window.navigator) == null ? void 0 : _b.product) === "ReactNative") ? React.useLayoutEffect : React.useEffect;
function useCallbackRef(fn) {
  const ref = React.useRef(fn);
  useIsomorphicLayoutEffect(() => void (ref.current = fn), [fn]);
  return ref;
}

// node_modules/@react-three/xr/dist/XREvents.mjs
function useXREvent(event, handler, { handedness } = {}) {
  const handlerRef = useCallbackRef(handler);
  const controllers = useXR((state) => state.controllers);
  useIsomorphicLayoutEffect(() => {
    const listeners = controllers.map((target) => {
      if (handedness && target.inputSource.handedness !== handedness)
        return;
      const listener = (nativeEvent) => handlerRef.current({ nativeEvent, target });
      target.controller.addEventListener(event, listener);
      return () => target.controller.removeEventListener(event, listener);
    });
    return () => listeners.forEach((cleanup) => cleanup == null ? void 0 : cleanup());
  }, [controllers, handedness, event]);
}

// node_modules/@react-three/xr/dist/Interactions.mjs
var tempMatrix = new Matrix4();
function InteractionManager({ children }) {
  const events = useThree((state) => state.events);
  const get = useThree((state) => state.get);
  const raycaster = useThree((state) => state.raycaster);
  const controllers = useXR((state) => state.controllers);
  const interactions = useXR((state) => state.interactions);
  const hoverState = useXR((state) => state.hoverState);
  const hasInteraction = useXR((state) => state.hasInteraction);
  const getInteraction = useXR((state) => state.getInteraction);
  const intersect = React2.useCallback(
    (controller) => {
      const objects = Array.from(interactions.keys());
      tempMatrix.identity().extractRotation(controller.matrixWorld);
      raycaster.ray.origin.setFromMatrixPosition(controller.matrixWorld);
      raycaster.ray.direction.set(0, 0, -1).applyMatrix4(tempMatrix);
      return raycaster.intersectObjects(objects, true);
    },
    [interactions, raycaster]
  );
  useFrame(() => {
    if (interactions.size === 0)
      return;
    for (const target of controllers) {
      const hovering = hoverState[target.inputSource.handedness];
      const hits = /* @__PURE__ */ new Set();
      let intersections = intersect(target.controller);
      if (events.filter) {
        intersections = events.filter(intersections, get());
      } else {
        const hit = intersections.find((i) => i == null ? void 0 : i.object);
        if (hit)
          intersections = [hit];
      }
      for (const intersection of intersections) {
        let eventObject = intersection.object;
        while (eventObject) {
          if (hasInteraction(eventObject, "onHover") && !hovering.has(eventObject)) {
            const handlers = getInteraction(eventObject, "onHover");
            for (const handler of handlers) {
              handler({ target, intersection, intersections });
            }
          }
          const moveHandlers = getInteraction(eventObject, "onMove");
          moveHandlers == null ? void 0 : moveHandlers.forEach((handler) => handler({ target, intersection, intersections }));
          hovering.set(eventObject, intersection);
          hits.add(eventObject.id);
          eventObject = eventObject.parent;
        }
      }
      for (const eventObject of hovering.keys()) {
        if (!hits.has(eventObject.id)) {
          hovering.delete(eventObject);
          const handlers = getInteraction(eventObject, "onBlur");
          if (!handlers)
            continue;
          for (const handler of handlers) {
            handler({ target, intersections });
          }
        }
      }
    }
  });
  const triggerEvent = React2.useCallback(
    (interaction) => (e) => {
      const hovering = hoverState[e.target.inputSource.handedness];
      const intersections = Array.from(new Set(hovering.values()));
      interactions.forEach((handlers, object) => {
        var _a2, _b2, _c;
        if (hovering.has(object)) {
          if (!handlers[interaction])
            return;
          for (const handler of handlers[interaction]) {
            (_a2 = handler.current) == null ? void 0 : _a2.call(handler, { target: e.target, intersection: hovering.get(object), intersections });
          }
        } else {
          if (interaction === "onSelect" && handlers["onSelectMissed"]) {
            for (const handler of handlers["onSelectMissed"]) {
              (_b2 = handler.current) == null ? void 0 : _b2.call(handler, { target: e.target, intersections });
            }
          } else if (interaction === "onSqueeze" && handlers["onSqueezeMissed"]) {
            for (const handler of handlers["onSqueezeMissed"]) {
              (_c = handler.current) == null ? void 0 : _c.call(handler, { target: e.target, intersections });
            }
          }
        }
      });
    },
    [hoverState, interactions]
  );
  useXREvent("select", triggerEvent("onSelect"));
  useXREvent("selectstart", triggerEvent("onSelectStart"));
  useXREvent("selectend", triggerEvent("onSelectEnd"));
  useXREvent("squeeze", triggerEvent("onSqueeze"));
  useXREvent("squeezeend", triggerEvent("onSqueezeEnd"));
  useXREvent("squeezestart", triggerEvent("onSqueezeStart"));
  return React2.createElement(React2.Fragment, null, children);
}
function useInteraction(ref, type, handler) {
  const addInteraction = useXR((state) => state.addInteraction);
  const removeInteraction = useXR((state) => state.removeInteraction);
  const handlerRef = useCallbackRef(handler);
  useIsomorphicLayoutEffect(() => {
    const target = ref.current;
    if (!target || !handlerRef.current)
      return;
    addInteraction(target, type, handlerRef);
    return () => removeInteraction(target, type, handlerRef);
  }, [ref, type, addInteraction, removeInteraction]);
}
var Interactive = React2.forwardRef(function Interactive2({
  onHover,
  onBlur,
  onSelectStart,
  onSelectEnd,
  onSelectMissed,
  onSelect,
  onSqueezeStart,
  onSqueezeEnd,
  onSqueezeMissed,
  onSqueeze,
  onMove,
  children
}, passedRef) {
  const ref = React2.useRef(null);
  React2.useImperativeHandle(passedRef, () => ref.current);
  useInteraction(ref, "onHover", onHover);
  useInteraction(ref, "onBlur", onBlur);
  useInteraction(ref, "onSelectStart", onSelectStart);
  useInteraction(ref, "onSelectEnd", onSelectEnd);
  useInteraction(ref, "onSelectMissed", onSelectMissed);
  useInteraction(ref, "onSelect", onSelect);
  useInteraction(ref, "onSqueezeStart", onSqueezeStart);
  useInteraction(ref, "onSqueezeEnd", onSqueezeEnd);
  useInteraction(ref, "onSqueezeMissed", onSqueezeMissed);
  useInteraction(ref, "onSqueeze", onSqueeze);
  useInteraction(ref, "onMove", onMove);
  return React2.createElement("group", {
    ref
  }, children);
});
var RayGrab = React2.forwardRef(function RayGrab2({ onSelectStart, onSelectEnd, children, ...rest }, forwardedRef) {
  const grabbingController = React2.useRef();
  const groupRef = React2.useRef(null);
  const previousTransform = React2.useMemo(() => new Matrix4(), []);
  React2.useImperativeHandle(forwardedRef, () => groupRef.current);
  useFrame(() => {
    const controller = grabbingController.current;
    const group = groupRef.current;
    if (!controller)
      return;
    group.applyMatrix4(previousTransform);
    group.applyMatrix4(controller.matrixWorld);
    group.updateMatrixWorld();
    previousTransform.copy(controller.matrixWorld).invert();
  });
  return React2.createElement(Interactive, {
    ref: groupRef,
    onSelectStart: (e) => {
      grabbingController.current = e.target.controller;
      previousTransform.copy(e.target.controller.matrixWorld).invert();
      onSelectStart == null ? void 0 : onSelectStart(e);
    },
    onSelectEnd: (e) => {
      if (e.target.controller === grabbingController.current) {
        grabbingController.current = void 0;
      }
      onSelectEnd == null ? void 0 : onSelectEnd(e);
    },
    ...rest
  }, children);
});
function useHitTest(hitTestCallback) {
  const session = useXR((state) => state.session);
  const hitTestSource = React2.useRef();
  const hitMatrix = React2.useMemo(() => new Matrix4(), []);
  useIsomorphicLayoutEffect(() => {
    if (!session)
      return void (hitTestSource.current = void 0);
    session.requestReferenceSpace("viewer").then(async (referenceSpace) => {
      var _a2;
      hitTestSource.current = await ((_a2 = session == null ? void 0 : session.requestHitTestSource) == null ? void 0 : _a2.call(session, { space: referenceSpace }));
    });
  }, [session]);
  useFrame((state, _, frame) => {
    if (!frame || !hitTestSource.current)
      return;
    const [hit] = frame.getHitTestResults(hitTestSource.current);
    if (hit) {
      const referenceSpace = state.gl.xr.getReferenceSpace();
      const pose = hit.getPose(referenceSpace);
      if (pose) {
        hitMatrix.fromArray(pose.transform.matrix);
        hitTestCallback(hitMatrix, hit);
      }
    }
  });
}

// node_modules/@react-three/xr/dist/XR.mjs
var XRContext = React3.createContext(null);
var globalSessionStore = create((set, get) => ({ set, get, session: null, referenceSpaceType: null }));
function XRManager({
  foveation = 0,
  referenceSpace = "local-floor",
  onSessionStart,
  onSessionEnd,
  onVisibilityChange,
  onInputSourcesChange,
  children
}) {
  const gl = useThree((state) => state.gl);
  const camera = useThree((state) => state.camera);
  const player = useXR((state) => state.player);
  const get = useXR((state) => state.get);
  const set = useXR((state) => state.set);
  const session = useXR((state) => state.session);
  const controllers = useXR((state) => state.controllers);
  const onSessionStartRef = useCallbackRef(onSessionStart);
  const onSessionEndRef = useCallbackRef(onSessionEnd);
  const onVisibilityChangeRef = useCallbackRef(onVisibilityChange);
  const onInputSourcesChangeRef = useCallbackRef(onInputSourcesChange);
  useIsomorphicLayoutEffect(() => {
    const handlers = [0, 1].map((id) => {
      const target = new XRController(id, gl);
      const onConnected = () => set((state) => ({ controllers: [...state.controllers, target] }));
      const onDisconnected = () => set((state) => ({ controllers: state.controllers.filter((it) => it !== target) }));
      target.addEventListener("connected", onConnected);
      target.addEventListener("disconnected", onDisconnected);
      return () => {
        target.removeEventListener("connected", onConnected);
        target.removeEventListener("disconnected", onDisconnected);
      };
    });
    return () => handlers.forEach((cleanup) => cleanup());
  }, [gl, set]);
  useIsomorphicLayoutEffect(() => globalSessionStore.subscribe(({ session: session2 }) => set(() => ({ session: session2 }))), [gl.xr, set]);
  useIsomorphicLayoutEffect(() => {
    gl.xr.setFoveation(foveation);
    set(() => ({ foveation }));
  }, [gl.xr, foveation, set]);
  useIsomorphicLayoutEffect(() => {
    const globalSessionState = globalSessionStore.getState();
    gl.xr.setReferenceSpaceType(referenceSpace);
    set(() => ({ referenceSpace }));
    globalSessionState.set({ referenceSpaceType: referenceSpace });
  }, [gl.xr, referenceSpace, set]);
  useIsomorphicLayoutEffect(() => {
    if (!session)
      return void gl.xr.setSession(null);
    const handleSessionStart = (nativeEvent) => {
      var _a2;
      set(() => ({ isPresenting: true }));
      (_a2 = onSessionStartRef.current) == null ? void 0 : _a2.call(onSessionStartRef, { nativeEvent: { ...nativeEvent, target: session }, target: session });
    };
    const handleSessionEnd = (nativeEvent) => {
      var _a2;
      set(() => ({ isPresenting: false, session: null }));
      globalSessionStore.setState(() => ({ session: null }));
      (_a2 = onSessionEndRef.current) == null ? void 0 : _a2.call(onSessionEndRef, { nativeEvent: { ...nativeEvent, target: session }, target: session });
    };
    const handleVisibilityChange = (nativeEvent) => {
      var _a2;
      (_a2 = onVisibilityChangeRef.current) == null ? void 0 : _a2.call(onVisibilityChangeRef, { nativeEvent, target: session });
    };
    const handleInputSourcesChange = (nativeEvent) => {
      var _a2;
      const isHandTracking = Object.values(session.inputSources).some((source) => source.hand);
      set(() => ({ isHandTracking }));
      (_a2 = onInputSourcesChangeRef.current) == null ? void 0 : _a2.call(onInputSourcesChangeRef, { nativeEvent, target: session });
    };
    gl.xr.addEventListener("sessionstart", handleSessionStart);
    gl.xr.addEventListener("sessionend", handleSessionEnd);
    session.addEventListener("visibilitychange", handleVisibilityChange);
    session.addEventListener("inputsourceschange", handleInputSourcesChange);
    gl.xr.setSession(session).then(() => {
      gl.xr.setFoveation(get().foveation);
    });
    return () => {
      gl.xr.removeEventListener("sessionstart", handleSessionStart);
      gl.xr.removeEventListener("sessionend", handleSessionEnd);
      session.removeEventListener("visibilitychange", handleVisibilityChange);
      session.removeEventListener("inputsourceschange", handleInputSourcesChange);
    };
  }, [session, gl.xr, set, get]);
  return React3.createElement(InteractionManager, null, React3.createElement("primitive", {
    object: player
  }, React3.createElement("primitive", {
    object: camera
  }), controllers.map((controller) => React3.createElement("primitive", {
    key: controller.index,
    object: controller
  }))), children);
}
function XR(props) {
  const store = React3.useMemo(
    () => create((set, get) => ({
      set,
      get,
      controllers: [],
      isPresenting: false,
      isHandTracking: false,
      player: new Group(),
      session: null,
      foveation: 0,
      referenceSpace: "local-floor",
      hoverState: {
        left: /* @__PURE__ */ new Map(),
        right: /* @__PURE__ */ new Map(),
        none: /* @__PURE__ */ new Map()
      },
      interactions: /* @__PURE__ */ new Map(),
      hasInteraction(object, eventType) {
        var _a2;
        return !!((_a2 = get().interactions.get(object)) == null ? void 0 : _a2[eventType].some((handlerRef) => handlerRef.current));
      },
      getInteraction(object, eventType) {
        var _a2;
        return (_a2 = get().interactions.get(object)) == null ? void 0 : _a2[eventType].reduce((result, handlerRef) => {
          if (handlerRef.current) {
            result.push(handlerRef.current);
          }
          return result;
        }, []);
      },
      addInteraction(object, eventType, handlerRef) {
        const interactions = get().interactions;
        if (!interactions.has(object)) {
          interactions.set(object, {
            onHover: [],
            onBlur: [],
            onSelect: [],
            onSelectEnd: [],
            onSelectStart: [],
            onSelectMissed: [],
            onSqueeze: [],
            onSqueezeEnd: [],
            onSqueezeStart: [],
            onSqueezeMissed: [],
            onMove: []
          });
        }
        const target = interactions.get(object);
        target[eventType].push(handlerRef);
      },
      removeInteraction(object, eventType, handlerRef) {
        const target = get().interactions.get(object);
        if (target) {
          const interactionIndex = target[eventType].indexOf(handlerRef);
          if (interactionIndex !== -1)
            target[eventType].splice(interactionIndex, 1);
        }
      }
    })),
    []
  );
  return React3.createElement(XRContext.Provider, {
    value: store
  }, React3.createElement(XRManager, {
    ...props
  }));
}
var getSessionOptions = (globalStateReferenceSpaceType, sessionInit) => {
  var _a2;
  if (!globalStateReferenceSpaceType && !sessionInit) {
    return void 0;
  }
  if (globalStateReferenceSpaceType && !sessionInit) {
    return { optionalFeatures: [globalStateReferenceSpaceType] };
  }
  if (globalStateReferenceSpaceType && sessionInit) {
    return { ...sessionInit, optionalFeatures: uniq([...(_a2 = sessionInit.optionalFeatures) != null ? _a2 : [], globalStateReferenceSpaceType]) };
  }
  return sessionInit;
};
var XRButton = React3.forwardRef(function XRButton2({ mode, sessionInit, enterOnly = false, exitOnly = false, onClick, onError, children, ...props }, ref) {
  const [status, setStatus] = React3.useState("exited");
  const label = status === "unsupported" ? `${mode} unsupported` : `${status === "entered" ? "Exit" : "Enter"} ${mode}`;
  const sessionMode = mode === "inline" ? mode : `immersive-${mode.toLowerCase()}`;
  const onErrorRef = useCallbackRef(onError);
  useIsomorphicLayoutEffect(() => {
    if (!(navigator == null ? void 0 : navigator.xr))
      return void setStatus("unsupported");
    navigator.xr.isSessionSupported(sessionMode).then((supported) => setStatus(supported ? "exited" : "unsupported"));
  }, [sessionMode]);
  useIsomorphicLayoutEffect(
    () => globalSessionStore.subscribe((state) => {
      if (state.session) {
        setStatus("entered");
      } else if (status !== "unsupported") {
        setStatus("exited");
      }
    }),
    [status]
  );
  const toggleSession = React3.useCallback(
    async (event) => {
      onClick == null ? void 0 : onClick(event);
      const xrState = globalSessionStore.getState();
      if (xrState.session && enterOnly)
        return;
      if (!xrState.session && exitOnly)
        return;
      let session = null;
      try {
        if (xrState.session) {
          await xrState.session.end();
        } else {
          const options = getSessionOptions(xrState.referenceSpaceType, sessionInit);
          session = await navigator.xr.requestSession(sessionMode, options);
        }
        xrState.set(() => ({ session }));
      } catch (e) {
        const onError2 = onErrorRef.current;
        if (onError2 && e instanceof Error)
          onError2(e);
        else
          throw e;
      }
    },
    [onClick, enterOnly, exitOnly, sessionMode, sessionInit, onErrorRef]
  );
  return React3.createElement("button", {
    ...props,
    ref,
    onClick: status === "unsupported" ? onClick : toggleSession
  }, typeof children === "function" ? children(status) : children != null ? children : label);
});
var buttonStyles = {
  position: "absolute",
  bottom: "24px",
  left: "50%",
  transform: "translateX(-50%)",
  padding: "12px 24px",
  border: "1px solid white",
  borderRadius: "4px",
  background: "rgba(0, 0, 0, 0.1)",
  color: "white",
  font: "normal 0.8125rem sans-serif",
  outline: "none",
  zIndex: 99999,
  cursor: "pointer"
};
var ARButton = React3.forwardRef(
  ({
    style = buttonStyles,
    sessionInit = {
      domOverlay: typeof document !== "undefined" ? { root: document.body } : void 0,
      optionalFeatures: ["hit-test", "dom-overlay", "dom-overlay-for-handheld-ar"]
    },
    children,
    ...rest
  }, ref) => React3.createElement(XRButton, {
    ...rest,
    ref,
    mode: "AR",
    style,
    sessionInit
  }, children)
);
var VRButton = React3.forwardRef(
  ({
    style = buttonStyles,
    sessionInit = { optionalFeatures: ["local-floor", "bounded-floor", "hand-tracking", "layers"] },
    children,
    ...rest
  }, ref) => React3.createElement(XRButton, {
    ...rest,
    ref,
    mode: "VR",
    style,
    sessionInit
  }, children)
);
function useXR(selector = (state) => state, equalityFn) {
  const store = React3.useContext(XRContext);
  if (!store)
    throw new Error("useXR must be used within an <XR /> component!");
  return store(selector, equalityFn);
}
function useController(handedness) {
  const controllers = useXR((state) => state.controllers);
  const controller = React3.useMemo(
    () => controllers.find(({ inputSource }) => inputSource.handedness === handedness),
    [handedness, controllers]
  );
  return controller;
}

// node_modules/@react-three/xr/dist/Controllers.mjs
var Ray = React4.forwardRef(function Ray2({ target, hideOnBlur = false, ...props }, forwardedRef) {
  const hoverState = useXR((state) => state.hoverState);
  const ray = React4.useRef(null);
  const rayGeometry = React4.useMemo(
    () => new BufferGeometry().setFromPoints([new Vector3(0, 0, 0), new Vector3(0, 0, -1)]),
    []
  );
  React4.useImperativeHandle(forwardedRef, () => ray.current);
  useFrame(() => {
    let rayLength = 1;
    const intersection = hoverState[target.inputSource.handedness].values().next().value;
    if (intersection && target.inputSource.handedness !== "none") {
      rayLength = intersection.distance;
      if (hideOnBlur)
        ray.current.visible = false;
    } else if (hideOnBlur) {
      ray.current.visible = true;
    }
    const offset = -0.01;
    ray.current.scale.z = rayLength + offset;
  });
  return React4.createElement("line", {
    ref: ray,
    geometry: rayGeometry,
    "material-opacity": 0.8,
    "material-transparent": true,
    ...props
  });
});
var modelFactory = new XRControllerModelFactory();
var ControllerModel = class extends Group {
  constructor(target) {
    super();
    this.add(modelFactory.createControllerModel(target.controller));
  }
};
function Controllers({ rayMaterial = {}, hideRaysOnBlur = false }) {
  const controllers = useXR((state) => state.controllers);
  const isHandTracking = useXR((state) => state.isHandTracking);
  const rayMaterialProps = React4.useMemo(
    () => Object.entries(rayMaterial).reduce(
      (acc, [key, value]) => ({
        ...acc,
        [`material-${key}`]: value
      }),
      {}
    ),
    [JSON.stringify(rayMaterial)]
  );
  React4.useMemo(() => extend({ ControllerModel }), []);
  useIsomorphicLayoutEffect(() => {
    for (const target of controllers) {
      target.controller.dispatchEvent({ type: "connected", data: target.inputSource, fake: true });
    }
  }, [controllers]);
  return React4.createElement(React4.Fragment, null, controllers.map((target, i) => React4.createElement(React4.Fragment, {
    key: i
  }, createPortal(React4.createElement("controllerModel", {
    args: [target]
  }), target.grip), createPortal(
    React4.createElement(Ray, {
      visible: !isHandTracking,
      hideOnBlur: hideRaysOnBlur,
      target,
      ...rayMaterialProps
    }),
    target.controller
  ))));
}

// node_modules/@react-three/xr/dist/Hands.mjs
var React5 = __toESM(require_react(), 1);
function Hands({ modelLeft, modelRight }) {
  const controllers = useXR((state) => state.controllers);
  React5.useMemo(() => extend({ OculusHandModel }), []);
  useIsomorphicLayoutEffect(() => {
    for (const target of controllers) {
      target.hand.dispatchEvent({ type: "connected", data: target.inputSource, fake: true });
    }
  }, [controllers, modelLeft, modelRight]);
  return React5.createElement(React5.Fragment, null, controllers.map(({ hand }) => createPortal(React5.createElement("oculusHandModel", {
    args: [hand, modelLeft, modelRight]
  }), hand)));
}
export {
  ARButton,
  Controllers,
  Hands,
  InteractionManager,
  Interactive,
  Ray,
  RayGrab,
  VRButton,
  XR,
  XRButton,
  XRController,
  useController,
  useHitTest,
  useInteraction,
  useXR,
  useXREvent
};
//# sourceMappingURL=@react-three_xr.js.map
